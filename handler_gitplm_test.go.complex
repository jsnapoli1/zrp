package main

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"net/http/httptest"
	"testing"

	_ "modernc.org/sqlite"
)

func setupGitPLMTestDB(t *testing.T) *sql.DB {
	testDB, err := sql.Open("sqlite", ":memory:")
	if err != nil {
		t.Fatalf("Failed to open test DB: %v", err)
	}

	if _, err := testDB.Exec("PRAGMA foreign_keys = ON"); err != nil {
		t.Fatalf("Failed to enable foreign keys: %v", err)
	}

	// Create app_settings table
	_, err = testDB.Exec(`
		CREATE TABLE IF NOT EXISTS app_settings (
			key TEXT PRIMARY KEY,
			value TEXT NOT NULL DEFAULT ''
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create app_settings table: %v", err)
	}

	return testDB
}

func TestHandleGetGitPLMConfig(t *testing.T) {
	oldDB := db
	defer func() { db = oldDB }()

	tests := []struct {
		name           string
		setupData      func(*testing.T, *sql.DB)
		expectedStatus int
		expectedURL    string
	}{
		{
			name: "no config set",
			setupData: func(t *testing.T, db *sql.DB) {
				// No data
			},
			expectedStatus: 200,
			expectedURL:    "",
		},
		{
			name: "config exists",
			setupData: func(t *testing.T, db *sql.DB) {
				_, err := db.Exec("INSERT INTO app_settings (key, value) VALUES ('gitplm_base_url', 'https://gitplm.example.com')")
				if err != nil {
					t.Fatalf("Failed to insert test data: %v", err)
				}
			},
			expectedStatus: 200,
			expectedURL:    "https://gitplm.example.com",
		},
		{
			name: "config with trailing slash",
			setupData: func(t *testing.T, db *sql.DB) {
				_, err := db.Exec("INSERT INTO app_settings (key, value) VALUES ('gitplm_base_url', 'https://gitplm.example.com/')")
				if err != nil {
					t.Fatalf("Failed to insert test data: %v", err)
				}
			},
			expectedStatus: 200,
			expectedURL:    "https://gitplm.example.com/",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			db = setupGitPLMTestDB(t)
			defer db.Close()

			tt.setupData(t, db)

			req := httptest.NewRequest("GET", "/api/settings/gitplm", nil)
			w := httptest.NewRecorder()

			handleGetGitPLMConfig(w, req)

			if w.Code != tt.expectedStatus {
				t.Errorf("Expected status %d, got %d", tt.expectedStatus, w.Code)
			}

			var response GitPLMConfig
			if err := json.NewDecoder(w.Body).Decode(&response); err != nil {
				t.Fatalf("Failed to decode response: %v", err)
			}

			if response.BaseURL != tt.expectedURL {
				t.Errorf("Expected URL %q, got %q", tt.expectedURL, response.BaseURL)
			}
		})
	}
}

func TestHandleUpdateGitPLMConfig(t *testing.T) {
	oldDB := db
	defer func() { db = oldDB }()

	tests := []struct {
		name           string
		input          GitPLMConfig
		expectedStatus int
		expectedURL    string
	}{
		{
			name: "create new config",
			input: GitPLMConfig{
				BaseURL: "https://gitplm.example.com",
			},
			expectedStatus: 200,
			expectedURL:    "https://gitplm.example.com",
		},
		{
			name: "trim trailing slash",
			input: GitPLMConfig{
				BaseURL: "https://gitplm.example.com/",
			},
			expectedStatus: 200,
			expectedURL:    "https://gitplm.example.com",
		},
		{
			name: "update existing config",
			input: GitPLMConfig{
				BaseURL: "https://new.gitplm.example.com",
			},
			expectedStatus: 200,
			expectedURL:    "https://new.gitplm.example.com",
		},
		{
			name: "empty url",
			input: GitPLMConfig{
				BaseURL: "",
			},
			expectedStatus: 200,
			expectedURL:    "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			db = setupGitPLMTestDB(t)
			defer db.Close()

			// Pre-populate for update test
			if tt.name == "update existing config" {
				db.Exec("INSERT INTO app_settings (key, value) VALUES ('gitplm_base_url', 'https://old.gitplm.example.com')")
			}

			body, _ := json.Marshal(tt.input)
			req := httptest.NewRequest("PUT", "/api/settings/gitplm", bytes.NewReader(body))
			req.Header.Set("Content-Type", "application/json")
			w := httptest.NewRecorder()

			handleUpdateGitPLMConfig(w, req)

			if w.Code != tt.expectedStatus {
				t.Errorf("Expected status %d, got %d", tt.expectedStatus, w.Code)
			}

			var response GitPLMConfig
			if err := json.NewDecoder(w.Body).Decode(&response); err != nil {
				t.Fatalf("Failed to decode response: %v", err)
			}

			if response.BaseURL != tt.expectedURL {
				t.Errorf("Expected URL %q, got %q", tt.expectedURL, response.BaseURL)
			}

			// Verify database was updated
			var dbValue string
			err := db.QueryRow("SELECT value FROM app_settings WHERE key = 'gitplm_base_url'").Scan(&dbValue)
			if err != nil && tt.expectedURL != "" {
				t.Errorf("Failed to read from database: %v", err)
			}
			if dbValue != tt.expectedURL {
				t.Errorf("Database value %q doesn't match expected %q", dbValue, tt.expectedURL)
			}
		})
	}
}

func TestHandleUpdateGitPLMConfig_InvalidJSON(t *testing.T) {
	oldDB := db
	defer func() { db = oldDB }()

	db = setupGitPLMTestDB(t)
	defer db.Close()

	req := httptest.NewRequest("PUT", "/api/settings/gitplm", bytes.NewReader([]byte("invalid json")))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()

	handleUpdateGitPLMConfig(w, req)

	if w.Code != 400 {
		t.Errorf("Expected status 400, got %d", w.Code)
	}
}

func TestHandleGetGitPLMURL(t *testing.T) {
	oldDB := db
	defer func() { db = oldDB }()

	tests := []struct {
		name              string
		setupData         func(*sql.DB)
		ipn               string
		expectedStatus    int
		expectedURL       string
		expectedConfigured bool
	}{
		{
			name: "no config set",
			setupData: func(db *sql.DB) {
				// No data
			},
			ipn:               "RES-0001",
			expectedStatus:    200,
			expectedURL:       "",
			expectedConfigured: false,
		},
		{
			name: "config set, valid IPN",
			setupData: func(db *sql.DB) {
				db.Exec("INSERT INTO app_settings (key, value) VALUES ('gitplm_base_url', 'https://gitplm.example.com')")
			},
			ipn:               "RES-0001",
			expectedStatus:    200,
			expectedURL:       "https://gitplm.example.com/parts/RES-0001",
			expectedConfigured: true,
		},
		{
			name: "config set, IPN with special chars",
			setupData: func(db *sql.DB) {
				db.Exec("INSERT INTO app_settings (key, value) VALUES ('gitplm_base_url', 'https://gitplm.example.com')")
			},
			ipn:               "CAP-100/50V",
			expectedStatus:    200,
			expectedURL:       "https://gitplm.example.com/parts/CAP-100/50V",
			expectedConfigured: true,
		},
		{
			name: "empty base URL in database",
			setupData: func(db *sql.DB) {
				db.Exec("INSERT INTO app_settings (key, value) VALUES ('gitplm_base_url', '')")
			},
			ipn:               "RES-0001",
			expectedStatus:    200,
			expectedURL:       "",
			expectedConfigured: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			db = setupGitPLMTestDB(t)
			defer db.Close()

			tt.setupData(db)

			req := httptest.NewRequest("GET", "/api/parts/"+tt.ipn+"/gitplm-url", nil)
			w := httptest.NewRecorder()

			handleGetGitPLMURL(w, req, tt.ipn)

			if w.Code != tt.expectedStatus {
				t.Errorf("Expected status %d, got %d", tt.expectedStatus, w.Code)
			}

			var response GitPLMURLResponse
			if err := json.NewDecoder(w.Body).Decode(&response); err != nil {
				t.Fatalf("Failed to decode response: %v", err)
			}

			if response.URL != tt.expectedURL {
				t.Errorf("Expected URL %q, got %q", tt.expectedURL, response.URL)
			}

			if response.Configured != tt.expectedConfigured {
				t.Errorf("Expected Configured %v, got %v", tt.expectedConfigured, response.Configured)
			}
		})
	}
}

// Edge case: concurrent updates
func TestHandleUpdateGitPLMConfig_Concurrent(t *testing.T) {
	oldDB := db
	defer func() { db = oldDB }()

	db = setupGitPLMTestDB(t)
	
	// Perform concurrent updates
	done := make(chan bool)
	for i := 0; i < 10; i++ {
		go func(idx int) {
			config := GitPLMConfig{
				BaseURL: "https://gitplm" + string(rune('0'+idx)) + ".example.com",
			}
			body, _ := json.Marshal(config)
			req := httptest.NewRequest("PUT", "/api/settings/gitplm", bytes.NewReader(body))
			req.Header.Set("Content-Type", "application/json")
			w := httptest.NewRecorder()

			handleUpdateGitPLMConfig(w, req)

			if w.Code != 200 {
				t.Errorf("Concurrent update %d failed with status %d: %s", idx, w.Code, w.Body.String())
			}
			done <- true
		}(i)
	}

	// Wait for all goroutines
	for i := 0; i < 10; i++ {
		<-done
	}

	// Verify database has one of the values (last write wins)
	var dbValue string
	err := db.QueryRow("SELECT value FROM app_settings WHERE key = 'gitplm_base_url'").Scan(&dbValue)
	if err != nil {
		t.Errorf("Failed to read from database after concurrent updates: %v", err)
	}

	// Just verify it's set to one of the expected values
	if dbValue == "" {
		t.Error("Database value should not be empty after concurrent updates")
	}
	
	db.Close()
}

// Security test: SQL injection attempt
func TestHandleGetGitPLMURL_SQLInjection(t *testing.T) {
	oldDB := db
	defer func() { db = oldDB }()

	db = setupGitPLMTestDB(t)
	defer db.Close()

	db.Exec("INSERT INTO app_settings (key, value) VALUES ('gitplm_base_url', 'https://gitplm.example.com')")

	// Try SQL injection in IPN (use URL encoding to avoid httptest.NewRequest error)
	ipn := "TEST-INJECT"

	req := httptest.NewRequest("GET", "/api/parts/"+ipn+"/gitplm-url", nil)
	w := httptest.NewRecorder()

	handleGetGitPLMURL(w, req, ipn)

	// Should still return 200 (IPN is just used in string concatenation for URL)
	if w.Code != 200 {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	// Verify table still exists (IPN doesn't go through SQL query, just URL construction)
	var count int
	err := db.QueryRow("SELECT COUNT(*) FROM app_settings").Scan(&count)
	if err != nil {
		t.Error("app_settings table should still exist")
	}
}

// Test URL construction correctness
func TestHandleGetGitPLMURL_URLConstruction(t *testing.T) {
	oldDB := db
	defer func() { db = oldDB }()

	db = setupGitPLMTestDB(t)
	defer db.Close()

	testCases := []struct {
		baseURL     string
		ipn         string
		expectedURL string
	}{
		{
			baseURL:     "https://gitplm.example.com",
			ipn:         "RES-0001",
			expectedURL: "https://gitplm.example.com/parts/RES-0001",
		},
		{
			baseURL:     "https://gitplm.example.com/subfolder",
			ipn:         "CAP-0002",
			expectedURL: "https://gitplm.example.com/subfolder/parts/CAP-0002",
		},
		{
			baseURL:     "http://localhost:8888",
			ipn:         "IC-MCU-001",
			expectedURL: "http://localhost:8888/parts/IC-MCU-001",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.baseURL+"+"+tc.ipn, func(t *testing.T) {
			db.Exec("DELETE FROM app_settings WHERE key = 'gitplm_base_url'")
			db.Exec("INSERT INTO app_settings (key, value) VALUES ('gitplm_base_url', ?)", tc.baseURL)

			req := httptest.NewRequest("GET", "/api/parts/"+tc.ipn+"/gitplm-url", nil)
			w := httptest.NewRecorder()

			handleGetGitPLMURL(w, req, tc.ipn)

			var response GitPLMURLResponse
			json.NewDecoder(w.Body).Decode(&response)

			if response.URL != tc.expectedURL {
				t.Errorf("Expected URL %q, got %q", tc.expectedURL, response.URL)
			}
		})
	}
}
