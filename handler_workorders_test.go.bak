package main

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http/httptest"
	"testing"

	_ "modernc.org/sqlite"
)

func setupWorkOrdersTestDB(t *testing.T) *sql.DB {
	testDB, err := sql.Open("sqlite", ":memory:")
	if err != nil {
		t.Fatalf("Failed to open test DB: %v", err)
	}

	if _, err := testDB.Exec("PRAGMA foreign_keys = ON"); err != nil {
		t.Fatalf("Failed to enable foreign keys: %v", err)
	}

	// Create work_orders table
	_, err = testDB.Exec(`
		CREATE TABLE work_orders (
			id TEXT PRIMARY KEY,
			assembly_ipn TEXT NOT NULL,
			qty INTEGER NOT NULL CHECK(qty > 0),
			qty_good INTEGER,
			qty_scrap INTEGER,
			status TEXT DEFAULT 'open' CHECK(status IN ('draft','open','in_progress','on_hold','completed','cancelled')),
			priority TEXT DEFAULT 'normal' CHECK(priority IN ('low','normal','high','urgent')),
			notes TEXT,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			started_at DATETIME,
			completed_at DATETIME
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create work_orders table: %v", err)
	}

	// Create wo_serials table
	_, err = testDB.Exec(`
		CREATE TABLE wo_serials (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			wo_id TEXT NOT NULL,
			serial_number TEXT NOT NULL UNIQUE,
			status TEXT DEFAULT 'building' CHECK(status IN ('building','testing','passed','failed','shipped')),
			notes TEXT,
			FOREIGN KEY (wo_id) REFERENCES work_orders(id) ON DELETE CASCADE
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create wo_serials table: %v", err)
	}

	// Create inventory table
	_, err = testDB.Exec(`
		CREATE TABLE inventory (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			ipn TEXT UNIQUE NOT NULL,
			description TEXT,
			qty_on_hand REAL DEFAULT 0,
			qty_reserved REAL DEFAULT 0,
			min_qty REAL DEFAULT 0,
			location TEXT,
			updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create inventory table: %v", err)
	}

	// Create inventory_transactions table
	_, err = testDB.Exec(`
		CREATE TABLE inventory_transactions (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			ipn TEXT NOT NULL,
			type TEXT CHECK(type IN ('receive','issue','adjust','transfer','return')),
			qty REAL NOT NULL,
			reference TEXT,
			notes TEXT,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create inventory_transactions table: %v", err)
	}

	// Create audit_log table
	_, err = testDB.Exec(`
		CREATE TABLE audit_log (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			user_id INTEGER,
			username TEXT DEFAULT 'system',
			action TEXT NOT NULL,
			module TEXT NOT NULL,
			record_id TEXT NOT NULL,
			summary TEXT,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create audit_log table: %v", err)
	}

	// Create part_changes table
	_, err = testDB.Exec(`
		CREATE TABLE part_changes (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			user TEXT,
			table_name TEXT,
			record_id TEXT,
			operation TEXT,
			old_snapshot TEXT,
			new_snapshot TEXT,
			timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create part_changes table: %v", err)
	}

	return testDB
}

func insertTestWorkOrder(t *testing.T, db *sql.DB, id, assemblyIPN string, qty int, status, priority, notes string) {
	_, err := db.Exec(
		"INSERT INTO work_orders (id, assembly_ipn, qty, status, priority, notes, created_at) VALUES (?, ?, ?, ?, ?, ?, datetime('now'))",
		id, assemblyIPN, qty, status, priority, notes,
	)
	if err != nil {
		t.Fatalf("Failed to insert test work order: %v", err)
	}
}

func insertTestInventory(t *testing.T, db *sql.DB, ipn string, qtyOnHand, qtyReserved float64) {
	_, err := db.Exec(
		"INSERT INTO inventory (ipn, qty_on_hand, qty_reserved, updated_at) VALUES (?, ?, ?, datetime('now'))",
		ipn, qtyOnHand, qtyReserved,
	)
	if err != nil {
		t.Fatalf("Failed to insert test inventory: %v", err)
	}
}

// Test List Work Orders - Empty
func TestHandleListWorkOrders_Empty(t *testing.T) {
	oldDB := db
	db = setupWorkOrdersTestDB(t)
	defer func() { db.Close(); db = oldDB }()

	req := httptest.NewRequest("GET", "/api/workorders", nil)
	w := httptest.NewRecorder()

	handleListWorkOrders(w, req)

	if w.Code != 200 {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	var resp APIResponse
	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
		t.Fatalf("Failed to decode response: %v", err)
	}

	orders, ok := resp.Data.([]interface{})
	if !ok {
		t.Fatalf("Expected data to be an array")
	}

	if len(orders) != 0 {
		t.Errorf("Expected empty array, got %d work orders", len(orders))
	}
}

// Test Create Work Order - Valid
func TestHandleCreateWorkOrder_Valid(t *testing.T) {
	oldDB := db
	db = setupWorkOrdersTestDB(t)
	defer func() { db.Close(); db = oldDB }()

	wo := WorkOrder{
		AssemblyIPN: "ASSY-001",
		Qty:         10,
		Status:      "open",
		Priority:    "normal",
		Notes:       "Test work order",
	}

	body, _ := json.Marshal(wo)
	req := httptest.NewRequest("POST", "/api/workorders", bytes.NewReader(body))
	w := httptest.NewRecorder()

	handleCreateWorkOrder(w, req)

	if w.Code != 200 {
		t.Errorf("Expected status 200, got %d: %s", w.Code, w.Body.String())
	}
}

// Test Update Work Order - Valid Status Transitions
func TestHandleUpdateWorkOrder_ValidStatusTransition(t *testing.T) {
	oldDB := db
	db = setupWorkOrdersTestDB(t)
	defer func() { db.Close(); db = oldDB }()

	insertTestWorkOrder(t, db, "WO-0001", "ASSY-001", 10, "open", "normal", "Test")

	wo := WorkOrder{
		AssemblyIPN: "ASSY-001",
		Qty:         10,
		Status:      "in_progress",
		Priority:    "normal",
	}

	body, _ := json.Marshal(wo)
	req := httptest.NewRequest("PUT", "/api/workorders/WO-0001", bytes.NewReader(body))
	w := httptest.NewRecorder()

	handleUpdateWorkOrder(w, req, "WO-0001")

	if w.Code != 200 {
		t.Errorf("Expected status 200, got %d: %s", w.Code, w.Body.String())
	}
}
