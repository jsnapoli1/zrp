package main

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	_ "modernc.org/sqlite"
)

func setupCSRFTestDB(t *testing.T) (*sql.DB, func()) {
	testDB, err := sql.Open("sqlite", ":memory:")
	if err != nil {
		t.Fatalf("Failed to open test DB: %v", err)
	}

	// Create all required tables
	schema := `
		CREATE TABLE users (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			username TEXT UNIQUE NOT NULL,
			password TEXT NOT NULL,
			email TEXT,
			role TEXT DEFAULT 'user',
			active INTEGER DEFAULT 1,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP
		);

		CREATE TABLE sessions (
			token TEXT PRIMARY KEY,
			user_id INTEGER NOT NULL,
			expires_at DATETIME NOT NULL,
			FOREIGN KEY (user_id) REFERENCES users(id)
		);

		CREATE TABLE parts (
			ipn TEXT PRIMARY KEY,
			description TEXT,
			category TEXT,
			lifecycle TEXT DEFAULT 'Active',
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP
		);

		CREATE TABLE categories (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			name TEXT UNIQUE NOT NULL
		);

		CREATE TABLE bom (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			parent_ipn TEXT NOT NULL,
			child_ipn TEXT NOT NULL,
			quantity INTEGER DEFAULT 1,
			FOREIGN KEY (parent_ipn) REFERENCES parts(ipn),
			FOREIGN KEY (child_ipn) REFERENCES parts(ipn)
		);

		CREATE TABLE vendors (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			name TEXT UNIQUE NOT NULL,
			contact_email TEXT,
			phone TEXT
		);

		CREATE TABLE devices (
			serial_number TEXT PRIMARY KEY,
			ipn TEXT,
			status TEXT DEFAULT 'Active',
			FOREIGN KEY (ipn) REFERENCES parts(ipn)
		);

		CREATE TABLE workorders (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			wo_number TEXT UNIQUE NOT NULL,
			ipn TEXT,
			quantity INTEGER,
			status TEXT DEFAULT 'Open',
			FOREIGN KEY (ipn) REFERENCES parts(ipn)
		);

		CREATE TABLE ncr (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			ncr_number TEXT UNIQUE NOT NULL,
			description TEXT,
			status TEXT DEFAULT 'Open'
		);

		CREATE TABLE capa (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			capa_number TEXT UNIQUE NOT NULL,
			description TEXT,
			status TEXT DEFAULT 'Open'
		);

		CREATE TABLE procurement (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			po_number TEXT UNIQUE NOT NULL,
			vendor_id INTEGER,
			status TEXT DEFAULT 'Draft',
			FOREIGN KEY (vendor_id) REFERENCES vendors(id)
		);

		CREATE TABLE invoices (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			invoice_number TEXT UNIQUE NOT NULL,
			amount REAL,
			status TEXT DEFAULT 'Draft'
		);

		CREATE TABLE sales_orders (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			so_number TEXT UNIQUE NOT NULL,
			customer TEXT,
			status TEXT DEFAULT 'Draft'
		);

		CREATE TABLE inventory (
			ipn TEXT PRIMARY KEY,
			location TEXT DEFAULT 'Main',
			quantity INTEGER DEFAULT 0,
			FOREIGN KEY (ipn) REFERENCES parts(ipn)
		);

		CREATE TABLE part_changes (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			eco_number TEXT UNIQUE NOT NULL,
			ipn TEXT,
			status TEXT DEFAULT 'Draft',
			FOREIGN KEY (ipn) REFERENCES parts(ipn)
		);

		CREATE TABLE csrf_tokens (
			token TEXT PRIMARY KEY,
			user_id INTEGER NOT NULL,
			expires_at DATETIME NOT NULL,
			FOREIGN KEY (user_id) REFERENCES users(id)
		);
	`

	_, err = testDB.Exec(schema)
	if err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}

	// Seed test data
	_, err = testDB.Exec(`
		INSERT INTO users (id, username, password, email, role) VALUES 
		(1, 'admin', '$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy', 'admin@test.com', 'admin'),
		(2, 'user', '$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy', 'user@test.com', 'user')
	`)
	if err != nil {
		t.Fatalf("Failed to seed users: %v", err)
	}

	// Create test session
	sessionToken := "test-session-token-123"
	expiresAt := time.Now().Add(24 * time.Hour)
	_, err = testDB.Exec("INSERT INTO sessions (token, user_id, expires_at) VALUES (?, 1, ?)",
		sessionToken, expiresAt.Format("2006-01-02 15:04:05"))
	if err != nil {
		t.Fatalf("Failed to create test session: %v", err)
	}

	// Seed some test data
	_, err = testDB.Exec("INSERT INTO parts (ipn, description, category) VALUES ('TEST-001', 'Test Part', 'Resistors')")
	if err != nil {
		t.Fatalf("Failed to seed parts: %v", err)
	}

	_, err = testDB.Exec("INSERT INTO vendors (id, name, contact_email) VALUES (1, 'Test Vendor', 'vendor@test.com')")
	if err != nil {
		t.Fatalf("Failed to seed vendors: %v", err)
	}

	cleanup := func() {
		testDB.Close()
	}

	return testDB, cleanup
}

// Helper function to create a valid CSRF token
func createCSRFToken(db *sql.DB, userID int) (string, error) {
	token := "csrf-token-" + time.Now().Format("20060102150405")
	expiresAt := time.Now().Add(1 * time.Hour)
	_, err := db.Exec("INSERT INTO csrf_tokens (token, user_id, expires_at) VALUES (?, ?, ?)",
		token, userID, expiresAt.Format("2006-01-02 15:04:05"))
	return token, err
}

// Helper to make authenticated request with optional CSRF token
func makeAuthenticatedRequest(method, path string, body []byte, csrfToken string) *http.Request {
	var req *http.Request
	if body != nil {
		req = httptest.NewRequest(method, path, bytes.NewReader(body))
		req.Header.Set("Content-Type", "application/json")
	} else {
		req = httptest.NewRequest(method, path, nil)
	}

	// Add session cookie
	req.AddCookie(&http.Cookie{
		Name:  "zrp_session",
		Value: "test-session-token-123",
	})

	// Add CSRF token if provided
	if csrfToken != "" {
		req.Header.Set("X-CSRF-Token", csrfToken)
	}

	return req
}

// Test 1: POST /api/v1/parts (Create Part) - No CSRF token
func TestCSRF_CreatePart_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"ipn":"NEW-001","description":"New Part","category":"Resistors"}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/parts", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreatePart))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}

	var resp map[string]string
	json.NewDecoder(w.Body).Decode(&resp)
	if !strings.Contains(resp["error"], "CSRF") {
		t.Errorf("Expected CSRF error message, got: %v", resp)
	}
}

// Test 2: POST /api/v1/parts - Invalid CSRF token
func TestCSRF_CreatePart_InvalidToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"ipn":"NEW-002","description":"New Part","category":"Resistors"}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/parts", body, "invalid-token-xyz")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreatePart))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden with invalid CSRF token, got %d", w.Code)
	}
}

// Test 3: POST /api/v1/parts - Valid CSRF token
func TestCSRF_CreatePart_ValidToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	csrfToken, err := createCSRFToken(testDB, 1)
	if err != nil {
		t.Fatalf("Failed to create CSRF token: %v", err)
	}

	body := []byte(`{"ipn":"NEW-003","description":"New Part","category":"Resistors"}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/parts", body, csrfToken)
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreatePart))
	handler.ServeHTTP(w, req)

	if w.Code == http.StatusForbidden {
		t.Errorf("Valid CSRF token should not be rejected, got %d: %s", w.Code, w.Body.String())
	}
}

// Test 4: PUT /api/v1/parts/{ipn} (Update Part) - No CSRF token
func TestCSRF_UpdatePart_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"description":"Updated Description"}`)
	req := makeAuthenticatedRequest("PUT", "/api/v1/parts/TEST-001", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handleUpdatePart(w, r, "TEST-001")
	}))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 5: DELETE /api/v1/parts/{ipn} - No CSRF token
func TestCSRF_DeletePart_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	req := makeAuthenticatedRequest("DELETE", "/api/v1/parts/TEST-001", nil, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handleDeletePart(w, r, "TEST-001")
	}))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 6: POST /api/v1/categories - No CSRF token
func TestCSRF_CreateCategory_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"name":"New Category"}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/categories", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreateCategory))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 7: POST /api/v1/vendors - No CSRF token
func TestCSRF_CreateVendor_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"name":"New Vendor","contact_email":"vendor@example.com"}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/vendors", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreateVendor))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 8: PUT /api/v1/vendors/{id} - No CSRF token
func TestCSRF_UpdateVendor_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"name":"Updated Vendor"}`)
	req := makeAuthenticatedRequest("PUT", "/api/v1/vendors/1", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handleUpdateVendor(w, r, "1")
	}))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 9: POST /api/v1/devices - No CSRF token
func TestCSRF_CreateDevice_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"serial_number":"SN001","ipn":"TEST-001","status":"Active"}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/devices", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreateDevice))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 10: PUT /api/v1/devices/{serial} - No CSRF token
func TestCSRF_UpdateDevice_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"status":"Retired"}`)
	req := makeAuthenticatedRequest("PUT", "/api/v1/devices/SN001", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handleUpdateDevice(w, r, "SN001")
	}))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 11: POST /api/v1/workorders - No CSRF token
func TestCSRF_CreateWorkOrder_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"wo_number":"WO-001","ipn":"TEST-001","quantity":10}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/workorders", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreateWorkOrder))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 12: PUT /api/v1/workorders/{id} - No CSRF token
func TestCSRF_UpdateWorkOrder_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"status":"Completed"}`)
	req := makeAuthenticatedRequest("PUT", "/api/v1/workorders/1", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handleUpdateWorkOrder(w, r, "1")
	}))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 13: POST /api/v1/ncr - No CSRF token
func TestCSRF_CreateNCR_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"ncr_number":"NCR-001","description":"Defect found"}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/ncr", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreateNCR))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 14: PUT /api/v1/ncr/{id} - No CSRF token
func TestCSRF_UpdateNCR_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"status":"Closed"}`)
	req := makeAuthenticatedRequest("PUT", "/api/v1/ncr/1", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handleUpdateNCR(w, r, "1")
	}))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 15: POST /api/v1/capa - No CSRF token
func TestCSRF_CreateCAPA_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"capa_number":"CAPA-001","description":"Corrective action"}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/capa", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreateCAPA))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 16: PUT /api/v1/capa/{id} - No CSRF token
func TestCSRF_UpdateCAPA_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"status":"Closed"}`)
	req := makeAuthenticatedRequest("PUT", "/api/v1/capa/1", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handleUpdateCAPA(w, r, "1")
	}))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 17: POST /api/v1/procurement - No CSRF token
func TestCSRF_CreateProcurement_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"po_number":"PO-001","vendor_id":1}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/procurement", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreateProcurement))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 18: PUT /api/v1/procurement/{id} - No CSRF token
func TestCSRF_UpdateProcurement_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"status":"Submitted"}`)
	req := makeAuthenticatedRequest("PUT", "/api/v1/procurement/1", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handleUpdateProcurement(w, r, "1")
	}))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 19: POST /api/v1/invoices - No CSRF token
func TestCSRF_CreateInvoice_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"invoice_number":"INV-001","amount":1000}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/invoices", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreateInvoice))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 20: PUT /api/v1/invoices/{id} - No CSRF token
func TestCSRF_UpdateInvoice_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"status":"Paid"}`)
	req := makeAuthenticatedRequest("PUT", "/api/v1/invoices/1", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handleUpdateInvoice(w, r, "1")
	}))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 21: POST /api/v1/sales-orders - No CSRF token
func TestCSRF_CreateSalesOrder_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"so_number":"SO-001","customer":"Test Customer"}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/sales-orders", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreateSalesOrder))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 22: PUT /api/v1/sales-orders/{id} - No CSRF token
func TestCSRF_UpdateSalesOrder_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"status":"Fulfilled"}`)
	req := makeAuthenticatedRequest("PUT", "/api/v1/sales-orders/1", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handleUpdateSalesOrder(w, r, "1")
	}))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 23: POST /api/v1/inventory/transact - No CSRF token
func TestCSRF_InventoryTransact_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"ipn":"TEST-001","quantity":10,"type":"add"}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/inventory/transact", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleInventoryTransact))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 24: POST /api/v1/part-changes - No CSRF token
func TestCSRF_CreatePartChange_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"eco_number":"ECO-001","ipn":"TEST-001"}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/part-changes", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreatePartChange))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 25: PUT /api/v1/part-changes/{id} - No CSRF token
func TestCSRF_UpdatePartChange_NoToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	body := []byte(`{"status":"Approved"}`)
	req := makeAuthenticatedRequest("PUT", "/api/v1/part-changes/1", body, "")
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handleUpdatePartChange(w, r, "1")
	}))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expected 403 Forbidden without CSRF token, got %d", w.Code)
	}
}

// Test 26: GET requests should NOT require CSRF token
func TestCSRF_GetRequests_NoTokenRequired(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	tests := []struct {
		name string
		path string
	}{
		{"List Parts", "/api/v1/parts"},
		{"Get Part", "/api/v1/parts/TEST-001"},
		{"List Vendors", "/api/v1/vendors"},
		{"List Devices", "/api/v1/devices"},
		{"List Work Orders", "/api/v1/workorders"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			req := makeAuthenticatedRequest("GET", tt.path, nil, "")
			w := httptest.NewRecorder()

			handler := csrfMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.WriteHeader(http.StatusOK)
				w.Write([]byte(`{"success":true}`))
			}))
			handler.ServeHTTP(w, req)

			if w.Code == http.StatusForbidden {
				t.Errorf("GET request should not require CSRF token for %s, got 403", tt.path)
			}
		})
	}
}

// Test 27: CSRF token tied to user session
func TestCSRF_TokenTiedToUserSession(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	// Create CSRF token for user 1
	csrfToken, err := createCSRFToken(testDB, 1)
	if err != nil {
		t.Fatalf("Failed to create CSRF token: %v", err)
	}

	// Create session for user 2
	sessionToken2 := "test-session-token-456"
	expiresAt := time.Now().Add(24 * time.Hour)
	_, err = testDB.Exec("INSERT INTO sessions (token, user_id, expires_at) VALUES (?, 2, ?)",
		sessionToken2, expiresAt.Format("2006-01-02 15:04:05"))
	if err != nil {
		t.Fatalf("Failed to create session for user 2: %v", err)
	}

	// Try to use user 1's CSRF token with user 2's session
	body := []byte(`{"ipn":"NEW-004","description":"Test Part","category":"Resistors"}`)
	req := httptest.NewRequest("POST", "/api/v1/parts", bytes.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	req.AddCookie(&http.Cookie{
		Name:  "zrp_session",
		Value: sessionToken2, // User 2's session
	})

	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreatePart))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("CSRF token from user 1 should not work with user 2's session, got %d", w.Code)
	}
}

// Test 28: Expired CSRF token should be rejected
func TestCSRF_ExpiredToken(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	// Create expired CSRF token
	expiredToken := "expired-csrf-token"
	expiresAt := time.Now().Add(-1 * time.Hour) // Expired 1 hour ago
	_, err := testDB.Exec("INSERT INTO csrf_tokens (token, user_id, expires_at) VALUES (?, 1, ?)",
		expiredToken, expiresAt.Format("2006-01-02 15:04:05"))
	if err != nil {
		t.Fatalf("Failed to create expired CSRF token: %v", err)
	}

	body := []byte(`{"ipn":"NEW-005","description":"Test Part","category":"Resistors"}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/parts", body, expiredToken)
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreatePart))
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusForbidden {
		t.Errorf("Expired CSRF token should be rejected, got %d", w.Code)
	}
}

// Test 29: CSRF token should expire with session logout
func TestCSRF_TokenExpiresWithSession(t *testing.T) {
	testDB, cleanup := setupCSRFTestDB(t)
	defer cleanup()
	db = testDB

	// Create CSRF token
	csrfToken, err := createCSRFToken(testDB, 1)
	if err != nil {
		t.Fatalf("Failed to create CSRF token: %v", err)
	}

	// Delete the session (simulate logout)
	_, err = testDB.Exec("DELETE FROM sessions WHERE token = ?", "test-session-token-123")
	if err != nil {
		t.Fatalf("Failed to delete session: %v", err)
	}

	// Try to use the CSRF token after logout
	body := []byte(`{"ipn":"NEW-006","description":"Test Part","category":"Resistors"}`)
	req := makeAuthenticatedRequest("POST", "/api/v1/parts", body, csrfToken)
	w := httptest.NewRecorder()

	handler := csrfMiddleware(http.HandlerFunc(handleCreatePart))
	handler.ServeHTTP(w, req)

	// Should fail because session is gone (authentication will fail first)
	if w.Code != http.StatusUnauthorized && w.Code != http.StatusForbidden {
		t.Errorf("Request should fail after session logout, got %d", w.Code)
	}
}
