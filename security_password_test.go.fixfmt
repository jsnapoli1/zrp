package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"golang.org/x/crypto/bcrypt"
)

func randomTestStr(n int) string {
	return fmt.Sprintf("%d", time.Now().UnixNano())[len(fmt.Sprintf("%d", time.Now().UnixNano()))-n:]
}

// TestPasswordHashing_BCryptUsed verifies passwords are hashed with bcrypt
func TestPasswordHashing_BCryptUsed(t *testing.T) {
	cleanup := setupTestDB(t)
	defer cleanup()

	cookie := loginAdmin(t)
	username := "hashtest_" + randomTestStr(8)
	password := "SecurePassword123!"

	body := map[string]string{
		"username":     username,
		"password":     password,
		"display_name": "Hash Test",
		"role":         "user",
	}
	bodyJSON, _ := json.Marshal(body)

	req := httptest.NewRequest("POST", "/api/v1/users", bytes.NewReader(bodyJSON))
	req.Header.Set("Content-Type", "application/json")
	req.AddCookie(cookie)
	w := httptest.NewRecorder()

	handleCreateUser(w, req)

	if w.Code != 201 {
		t.Fatalf("Failed to create user: %d - %s", w.Code, w.Body.String())
	}

	var storedHash string
	err := db.QueryRow("SELECT password_hash FROM users WHERE username = ?", username).Scan(&storedHash)
	if err != nil {
		t.Fatalf("Failed to query user: %v", err)
	}

	if storedHash == password {
		t.Error("SECURITY FAIL: Password stored in plain text!")
	}

	if !strings.HasPrefix(storedHash, "$2") {
		t.Errorf("Password doesn't appear to be bcrypt: %s", storedHash[:10])
	}

	err = bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(password))
	if err != nil {
		t.Errorf("Bcrypt comparison failed: %v", err)
	}

	t.Logf("✓ Password correctly hashed with bcrypt")
}

// TestPasswordComplexity_WeakPasswordsRejected tests weak password rejection
func TestPasswordComplexity_WeakPasswordsRejected(t *testing.T) {
	cleanup := setupTestDB(t)
	defer cleanup()

	cookie := loginAdmin(t)

	weakPasswords := []string{
		"123456",
		"password",
		"short",
		"12345678901",
		"abcdefghabcd",
	}

	for _, pwd := range weakPasswords {
		t.Run(pwd, func(t *testing.T) {
			username := "weak_" + randomTestStr(6)
			body := map[string]string{
				"username":     username,
				"password":     pwd,
				"display_name": "Test",
				"role":         "user",
			}
			bodyJSON, _ := json.Marshal(body)

			req := httptest.NewRequest("POST", "/api/v1/users", bytes.NewReader(bodyJSON))
			req.Header.Set("Content-Type", "application/json")
			req.AddCookie(cookie)
			w := httptest.NewRecorder()

			handleCreateUser(w, req)

			if w.Code != 400 {
				t.Errorf("Weak password accepted! Status: %d", w.Code)
			} else {
				t.Logf("✓ Weak password rejected")
			}
		})
	}
}

// TestPasswordComplexity_StrongPasswordsAccepted tests strong password acceptance
func TestPasswordComplexity_StrongPasswordsAccepted(t *testing.T) {
	cleanup := setupTestDB(t)
	defer cleanup()

	cookie := loginAdmin(t)

	strongPasswords := []string{
		"SecurePass123!",
		"MyP@ssw0rd2024",
		"C0mpl3x&Secure",
	}

	for _, pwd := range strongPasswords {
		t.Run(pwd, func(t *testing.T) {
			username := "strong_" + randomTestStr(6)
			body := map[string]string{
				"username":     username,
				"password":     pwd,
				"display_name": "Test",
				"role":         "user",
			}
			bodyJSON, _ := json.Marshal(body)

			req := httptest.NewRequest("POST", "/api/v1/users", bytes.NewReader(bodyJSON))
			req.Header.Set("Content-Type", "application/json")
			req.AddCookie(cookie)
			w := httptest.NewRecorder()

			handleCreateUser(w, req)

			if w.Code != 201 {
				t.Errorf("Strong password rejected: %d - %s", pwd, w.Code, w.Body.String())
			} else {
				t.Logf("✓ Strong password accepted")
			}
		})
	}
}

// TestBruteForceProtection_AccountLockout tests account lockout
func TestBruteForceProtection_AccountLockout(t *testing.T) {
	cleanup := setupTestDB(t)
	defer cleanup()

	resetLoginRateLimit()

	username := "lockout_" + randomTestStr(8)
	password := "CorrectPassword123!"
	hash, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	_, err := db.Exec("INSERT INTO users (username, password_hash, display_name, role, active) VALUES (?, ?, ?, ?, 1)",
		username, string(hash), "Test", "user")
	if err != nil {
		t.Fatalf("Failed to create user: %v", err)
	}

	for i := 0; i < 10; i++ {
		body := map[string]string{
			"username": username,
			"password": "WrongPassword123!",
		}
		bodyJSON, _ := json.Marshal(body)

		req := httptest.NewRequest("POST", "/api/v1/login", bytes.NewReader(bodyJSON))
		req.Header.Set("Content-Type", "application/json")
		req.RemoteAddr = "192.168.1.100:12345"
		w := httptest.NewRecorder()

		handleLogin(w, req)
		time.Sleep(10 * time.Millisecond)
	}

	body := map[string]string{
		"username": username,
		"password": password,
	}
	bodyJSON, _ := json.Marshal(body)

	req := httptest.NewRequest("POST", "/api/v1/login", bytes.NewReader(bodyJSON))
	req.Header.Set("Content-Type", "application/json")
	req.RemoteAddr = "192.168.1.100:12345"
	w := httptest.NewRecorder()

	handleLogin(w, req)

	if w.Code != 429 && w.Code != 403 {
		t.Errorf("Account NOT locked! Status: %d (expected 429 or 403)", w.Code)
	} else {
		t.Logf("✓ Account locked after 10 failed attempts (status: %d)", w.Code)
	}
}

// TestPasswordHistory_PreventReuse tests password history enforcement
func TestPasswordHistory_PreventReuse(t *testing.T) {
	cleanup := setupTestDB(t)
	defer cleanup()

	username := "history_" + randomTestStr(8)
	password1 := "FirstPassword123!"
	hash, _ := bcrypt.GenerateFromPassword([]byte(password1), bcrypt.DefaultCost)
	result, err := db.Exec("INSERT INTO users (username, password_hash, display_name, role, active) VALUES (?, ?, ?, ?, 1)",
		username, string(hash), "Test", "user")
	if err != nil {
		t.Fatalf("Failed to create user: %v", err)
	}
	userID64, _ := result.LastInsertId()
	userID := int(userID64)

	AddPasswordHistory(userID, string(hash))

	token := generateToken()
	expires := time.Now().Add(24 * time.Hour)
	_, _ = db.Exec("INSERT INTO sessions (token, user_id, expires_at) VALUES (?, ?, ?)",
		token, userID, expires.Format("2006-01-02 15:04:05"))
	cookie := &http.Cookie{Name: "zrp_session", Value: token}

	password2 := "SecondPassword456@"
	changeReq := map[string]string{
		"current_password": password1,
		"new_password":     password2,
	}
	changeJSON, _ := json.Marshal(changeReq)
	req := httptest.NewRequest("POST", "/api/v1/users/me/password", bytes.NewReader(changeJSON))
	req.Header.Set("Content-Type", "application/json")
	req.AddCookie(cookie)
	w := httptest.NewRecorder()
	handleChangePassword(w, req)

	if w.Code != 200 {
		t.Fatalf("Password change failed: %d - %s", w.Code, w.Body.String())
	}

	password3 := "ThirdPassword789#"
	changeReq = map[string]string{
		"current_password": password2,
		"new_password":     password3,
	}
	changeJSON, _ = json.Marshal(changeReq)
	req = httptest.NewRequest("POST", "/api/v1/users/me/password", bytes.NewReader(changeJSON))
	req.Header.Set("Content-Type", "application/json")
	req.AddCookie(cookie)
	w = httptest.NewRecorder()
	handleChangePassword(w, req)

	if w.Code != 200 {
		t.Fatalf("Password change failed: %d", w.Code)
	}

	changeReq = map[string]string{
		"current_password": password3,
		"new_password":     password1,
	}
	changeJSON, _ = json.Marshal(changeReq)
	req = httptest.NewRequest("POST", "/api/v1/users/me/password", bytes.NewReader(changeJSON))
	req.Header.Set("Content-Type", "application/json")
	req.AddCookie(cookie)
	w = httptest.NewRecorder()
	handleChangePassword(w, req)

	if w.Code == 200 {
		t.Error("FAIL: Password reuse was allowed!")
	} else {
		t.Logf("✓ Password reuse prevented")
	}
}

// TestPasswordResetToken_Expiration tests token expiration
func TestPasswordResetToken_Expiration(t *testing.T) {
	cleanup := setupTestDB(t)
	defer cleanup()

	username := "reset_" + randomTestStr(8)
	password := "OriginalPassword123!"
	hash, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	_, err := db.Exec("INSERT INTO users (username, password_hash, display_name, role, active) VALUES (?, ?, ?, ?, 1)",
		username, string(hash), "Test", "user")
	if err != nil {
		t.Fatalf("Failed to create user: %v", err)
	}

	token := generateToken()
	var userID int
	err = db.QueryRow("SELECT id FROM users WHERE username = ?", username).Scan(&userID)
	if err != nil {
		t.Fatalf("Failed to get user ID: %v", err)
	}

	expiresAt := time.Now().Add(1 * time.Hour)
	_, err = db.Exec("INSERT INTO password_reset_tokens (token, user_id, created_at, expires_at, used) VALUES (?, ?, CURRENT_TIMESTAMP, ?, 0)",
		token, userID, expiresAt.Format("2006-01-02 15:04:05"))
	if err != nil {
		t.Fatalf("Failed to create token: %v", err)
	}

	valid, gotUserID := ValidatePasswordResetToken(token)
	if !valid || gotUserID != userID {
		t.Errorf("Token invalid! valid=%v, userID=%d", valid, gotUserID)
	} else {
		t.Logf("✓ Token valid immediately")
	}

	_, err = db.Exec(`UPDATE password_reset_tokens SET expires_at = datetime('now', '-1 minutes') WHERE token = ?`, token)
	if err != nil {
		t.Fatalf("Failed to expire token: %v", err)
	}

	valid, _ = ValidatePasswordResetToken(token)
	if valid {
		t.Error("FAIL: Token still valid after expiration!")
	} else {
		t.Logf("✓ Token correctly expired")
	}
}

// TestPasswordResetToken_SingleUse tests single-use tokens
func TestPasswordResetToken_SingleUse(t *testing.T) {
	cleanup := setupTestDB(t)
	defer cleanup()

	username := "singleuse_" + randomTestStr(8)
	password := "OriginalPassword123!"
	hash, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	result, err := db.Exec("INSERT INTO users (username, password_hash, display_name, role, active) VALUES (?, ?, ?, ?, 1)",
		username, string(hash), "Test", "user")
	if err != nil {
		t.Fatalf("Failed to create user: %v", err)
	}
	userID64, _ := result.LastInsertId()
	userID := int(userID64)

	AddPasswordHistory(userID, string(hash))

	token, err := GeneratePasswordResetToken(username)
	if err != nil {
		t.Fatalf("Failed to generate token: %v", err)
	}

	newPassword := "NewPassword456@"
	err = ResetPasswordWithToken(token, newPassword)
	if err != nil {
		t.Logf("Password reset failed: %v", err)
		return
	}
	t.Logf("✓ Password reset successful")

	err = ResetPasswordWithToken(token, "AnotherPassword789#")
	if err == nil {
		t.Error("FAIL: Token was reusable!")
	} else {
		t.Logf("✓ Token correctly invalidated")
	}
}
