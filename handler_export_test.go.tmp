package main

import (
	"database/sql"
	"encoding/csv"
	"io"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	"fmt"
	"github.com/xuri/excelize/v2"
	_ "modernc.org/sqlite"
)

func setupExportTestDB(t *testing.T) *sql.DB {
	testDB, err := sql.Open("sqlite", ":memory:")
	if err != nil {
		t.Fatalf("Failed to open test DB: %v", err)
	}

	if _, err := testDB.Exec("PRAGMA foreign_keys = ON"); err != nil {
		t.Fatalf("Failed to enable foreign keys: %v", err)
	}

	// Create parts table
	_, err = testDB.Exec(`
		CREATE TABLE parts (
			ipn TEXT PRIMARY KEY,
			category TEXT,
			description TEXT,
			mpn TEXT,
			manufacturer TEXT,
			lifecycle TEXT DEFAULT 'active',
			notes TEXT
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create parts table: %v", err)
	}

	// Create inventory table
	_, err = testDB.Exec(`
		CREATE TABLE inventory (
			ipn TEXT PRIMARY KEY,
			qty_on_hand REAL DEFAULT 0,
			qty_reserved REAL DEFAULT 0,
			location TEXT,
			reorder_point REAL DEFAULT 0,
			reorder_qty REAL DEFAULT 0,
			description TEXT,
			mpn TEXT,
			updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create inventory table: %v", err)
	}

	// Create work_orders table
	_, err = testDB.Exec(`
		CREATE TABLE work_orders (
			id TEXT PRIMARY KEY,
			assembly_ipn TEXT NOT NULL,
			qty INTEGER DEFAULT 1,
			qty_good INTEGER DEFAULT 0,
			qty_scrap INTEGER DEFAULT 0,
			status TEXT DEFAULT 'pending',
			priority TEXT DEFAULT 'normal',
			notes TEXT,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			started_at DATETIME,
			completed_at DATETIME
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create work_orders table: %v", err)
	}

	// Create ecos table
	_, err = testDB.Exec(`
		CREATE TABLE ecos (
			id TEXT PRIMARY KEY,
			title TEXT NOT NULL,
			description TEXT,
			status TEXT DEFAULT 'draft',
			priority TEXT DEFAULT 'normal',
			affected_ipns TEXT,
			created_by TEXT,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			updated_at DATETIME,
			approved_at DATETIME,
			approved_by TEXT,
			ncr_id TEXT
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create ecos table: %v", err)
	}

	// Create vendors table
	_, err = testDB.Exec(`
		CREATE TABLE vendors (
			id TEXT PRIMARY KEY,
			name TEXT NOT NULL,
			website TEXT,
			contact_name TEXT,
			contact_email TEXT,
			contact_phone TEXT,
			notes TEXT,
			status TEXT DEFAULT 'active',
			lead_time_days INTEGER DEFAULT 0,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create vendors table: %v", err)
	}

	// Create data_exports table for logging
	_, err = testDB.Exec(`
		CREATE TABLE data_exports (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			user_id TEXT,
			entity_type TEXT,
			format TEXT,
			record_count INTEGER,
			exported_at DATETIME DEFAULT CURRENT_TIMESTAMP
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create data_exports table: %v", err)
	}

	return testDB
}

func insertExportTestData(t *testing.T, db *sql.DB) {
	// Insert parts
	for i := 1; i <= 5; i++ {
		_, err := db.Exec(`INSERT INTO parts (ipn, category, description, mpn, manufacturer, lifecycle, notes) 
			VALUES (?, ?, ?, ?, ?, ?, ?)`,
			fmt.Sprintf("PART-%03d", i),
			"Electronics",
			fmt.Sprintf("Test Part %d", i),
			fmt.Sprintf("MPN-%03d", i),
			"Test Mfg",
			"active",
			"Test notes")
		if err != nil {
			t.Fatalf("Failed to insert part: %v", err)
		}
	}

	// Insert inventory
	for i := 1; i <= 5; i++ {
		_, err := db.Exec(`INSERT INTO inventory (ipn, qty_on_hand, qty_reserved, location, reorder_point, reorder_qty, description, mpn) 
			VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
			fmt.Sprintf("PART-%03d", i),
			float64(i*10),
			float64(i),
			fmt.Sprintf("LOC-%d", i),
			float64(i*2),
			float64(i*5),
			fmt.Sprintf("Inventory Item %d", i),
			fmt.Sprintf("MPN-%03d", i))
		if err != nil {
			t.Fatalf("Failed to insert inventory: %v", err)
		}
	}

	// Insert work orders
	for i := 1; i <= 5; i++ {
		_, err := db.Exec(`INSERT INTO work_orders (id, assembly_ipn, qty, qty_good, qty_scrap, status, priority, notes) 
			VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
			fmt.Sprintf("WO-%03d", i),
			"ASSY-100",
			i*10,
			i*8,
			i,
			"pending",
			"normal",
			"Test WO")
		if err != nil {
			t.Fatalf("Failed to insert work order: %v", err)
		}
	}

	// Insert ECOs
	for i := 1; i <= 5; i++ {
		_, err := db.Exec(`INSERT INTO ecos (id, title, description, status, priority, created_by) 
			VALUES (?, ?, ?, ?, ?, ?)`,
			fmt.Sprintf("ECO-%03d", i),
			fmt.Sprintf("ECO Title %d", i),
			fmt.Sprintf("Description %d", i),
			"draft",
			"normal",
			"test-user")
		if err != nil {
			t.Fatalf("Failed to insert ECO: %v", err)
		}
	}

	// Insert vendors
	for i := 1; i <= 5; i++ {
		_, err := db.Exec(`INSERT INTO vendors (id, name, website, contact_name, contact_email, status, lead_time_days) 
			VALUES (?, ?, ?, ?, ?, ?, ?)`,
			fmt.Sprintf("VENDOR-%03d", i),
			fmt.Sprintf("Vendor %d", i),
			fmt.Sprintf("https://vendor%d.com", i),
			fmt.Sprintf("Contact %d", i),
			fmt.Sprintf("contact%d@vendor.com", i),
			"active",
			i*7)
		if err != nil {
			t.Fatalf("Failed to insert vendor: %v", err)
		}
	}
}

func TestHandleExportParts_CSV(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	insertExportTestData(t, db)

	req := httptest.NewRequest("GET", "/api/export/parts?format=csv", nil)
	w := httptest.NewRecorder()

	handleExportParts(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	contentType := w.Header().Get("Content-Type")
	if contentType != "text/csv" {
		t.Errorf("Expected Content-Type 'text/csv', got '%s'", contentType)
	}

	disposition := w.Header().Get("Content-Disposition")
	if !strings.Contains(disposition, "parts.csv") {
		t.Errorf("Expected Content-Disposition to contain 'parts.csv', got '%s'", disposition)
	}

	// Parse CSV
	reader := csv.NewReader(w.Body)
	records, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("Failed to parse CSV: %v", err)
	}

	// Should have header + 5 data rows
	if len(records) != 6 {
		t.Errorf("Expected 6 rows (1 header + 5 data), got %d", len(records))
	}

	// Verify header
	expectedHeaders := []string{"IPN", "Category", "Description", "MPN", "Manufacturer", "Lifecycle", "Notes"}
	if len(records) > 0 {
		for i, expected := range expectedHeaders {
			if i >= len(records[0]) || records[0][i] != expected {
				t.Errorf("Expected header[%d] to be '%s', got '%s'", i, expected, records[0][i])
			}
		}
	}

	// Verify first data row
	if len(records) > 1 {
		if !strings.HasPrefix(records[1][0], "PART-") {
			t.Errorf("Expected first data row to start with 'PART-', got '%s'", records[1][0])
		}
	}
}

func TestHandleExportParts_Excel(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	insertExportTestData(t, db)

	req := httptest.NewRequest("GET", "/api/export/parts?format=xlsx", nil)
	w := httptest.NewRecorder()

	handleExportParts(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	contentType := w.Header().Get("Content-Type")
	if !strings.Contains(contentType, "spreadsheetml") {
		t.Errorf("Expected Content-Type to contain 'spreadsheetml', got '%s'", contentType)
	}

	disposition := w.Header().Get("Content-Disposition")
	if !strings.Contains(disposition, ".xlsx") {
		t.Errorf("Expected Content-Disposition to contain '.xlsx', got '%s'", disposition)
	}

	// Parse Excel file
	f, err := excelize.OpenReader(w.Body)
	if err != nil {
		t.Fatalf("Failed to parse Excel file: %v", err)
	}
	defer f.Close()

	// Check sheet exists
	sheets := f.GetSheetList()
	if len(sheets) == 0 {
		t.Fatal("Expected at least one sheet in Excel file")
	}

	// Read rows
	rows, err := f.GetRows(sheets[0])
	if err != nil {
		t.Fatalf("Failed to read rows: %v", err)
	}

	// Should have header + 5 data rows
	if len(rows) != 6 {
		t.Errorf("Expected 6 rows (1 header + 5 data), got %d", len(rows))
	}
}

func TestHandleExportParts_WithSearch(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	insertExportTestData(t, db)

	req := httptest.NewRequest("GET", "/api/export/parts?format=csv&search=PART-001", nil)
	w := httptest.NewRecorder()

	handleExportParts(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	reader := csv.NewReader(w.Body)
	records, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("Failed to parse CSV: %v", err)
	}

	// Should have header + 1 data row (filtered)
	if len(records) != 2 {
		t.Errorf("Expected 2 rows (1 header + 1 data), got %d", len(records))
	}

	if len(records) > 1 && records[1][0] != "PART-001" {
		t.Errorf("Expected filtered result 'PART-001', got '%s'", records[1][0])
	}
}

func TestHandleExportParts_WithCategory(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	// Insert parts with different categories
	db.Exec("INSERT INTO parts (ipn, category, description) VALUES (?, ?, ?)", "CAT-001", "Cat1", "Test")
	db.Exec("INSERT INTO parts (ipn, category, description) VALUES (?, ?, ?)", "CAT-002", "Cat2", "Test")

	req := httptest.NewRequest("GET", "/api/export/parts?format=csv&category=Cat1", nil)
	w := httptest.NewRecorder()

	handleExportParts(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	reader := csv.NewReader(w.Body)
	records, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("Failed to parse CSV: %v", err)
	}

	// Should only return parts from Cat1
	dataRows := len(records) - 1 // Exclude header
	if dataRows != 1 {
		t.Errorf("Expected 1 data row for category filter, got %d", dataRows)
	}
}

func TestHandleExportInventory_CSV(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	insertExportTestData(t, db)

	req := httptest.NewRequest("GET", "/api/export/inventory?format=csv", nil)
	w := httptest.NewRecorder()

	handleExportInventory(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	reader := csv.NewReader(w.Body)
	records, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("Failed to parse CSV: %v", err)
	}

	if len(records) != 6 {
		t.Errorf("Expected 6 rows, got %d", len(records))
	}

	// Verify numeric formatting
	if len(records) > 1 && len(records[1]) > 1 {
		qtyOnHand := records[1][1] // Should be formatted number
		if qtyOnHand == "" {
			t.Error("Expected qty_on_hand to be present")
		}
	}
}

func TestHandleExportInventory_LowStock(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	// Insert inventory with low stock (qty <= reorder_point)
	db.Exec("INSERT INTO inventory (ipn, qty_on_hand, reorder_point, location) VALUES (?, ?, ?, ?)",
		"LOW-001", 5.0, 10.0, "A1")
	db.Exec("INSERT INTO inventory (ipn, qty_on_hand, reorder_point, location) VALUES (?, ?, ?, ?)",
		"OK-001", 50.0, 10.0, "B1")

	req := httptest.NewRequest("GET", "/api/export/inventory?format=csv&low_stock=true", nil)
	w := httptest.NewRecorder()

	handleExportInventory(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	reader := csv.NewReader(w.Body)
	records, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("Failed to parse CSV: %v", err)
	}

	// Should only return low stock item
	dataRows := len(records) - 1
	if dataRows != 1 {
		t.Errorf("Expected 1 low stock item, got %d", dataRows)
	}

	if len(records) > 1 && records[1][0] != "LOW-001" {
		t.Errorf("Expected 'LOW-001', got '%s'", records[1][0])
	}
}

func TestHandleExportWorkOrders_CSV(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	insertExportTestData(t, db)

	req := httptest.NewRequest("GET", "/api/export/workorders?format=csv", nil)
	w := httptest.NewRecorder()

	handleExportWorkOrders(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	reader := csv.NewReader(w.Body)
	records, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("Failed to parse CSV: %v", err)
	}

	if len(records) != 6 {
		t.Errorf("Expected 6 rows, got %d", len(records))
	}
}

func TestHandleExportWorkOrders_StatusFilter(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	db.Exec("INSERT INTO work_orders (id, assembly_ipn, status) VALUES (?, ?, ?)", "WO-PEND", "ASSY", "pending")
	db.Exec("INSERT INTO work_orders (id, assembly_ipn, status) VALUES (?, ?, ?)", "WO-COMP", "ASSY", "completed")

	req := httptest.NewRequest("GET", "/api/export/workorders?format=csv&status=pending", nil)
	w := httptest.NewRecorder()

	handleExportWorkOrders(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	reader := csv.NewReader(w.Body)
	records, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("Failed to parse CSV: %v", err)
	}

	dataRows := len(records) - 1
	if dataRows != 1 {
		t.Errorf("Expected 1 pending work order, got %d", dataRows)
	}
}

func TestHandleExportECOs_CSV(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	insertExportTestData(t, db)

	req := httptest.NewRequest("GET", "/api/export/ecos?format=csv", nil)
	w := httptest.NewRecorder()

	handleExportECOs(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	reader := csv.NewReader(w.Body)
	records, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("Failed to parse CSV: %v", err)
	}

	if len(records) != 6 {
		t.Errorf("Expected 6 rows, got %d", len(records))
	}
}

func TestHandleExportVendors_CSV(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	insertExportTestData(t, db)

	req := httptest.NewRequest("GET", "/api/export/vendors?format=csv", nil)
	w := httptest.NewRecorder()

	handleExportVendors(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	reader := csv.NewReader(w.Body)
	records, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("Failed to parse CSV: %v", err)
	}

	if len(records) != 6 {
		t.Errorf("Expected 6 rows, got %d", len(records))
	}
}

func TestHandleExport_LargeDataset(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	// Insert 1000 parts
	for i := 1; i <= 1000; i++ {
		db.Exec("INSERT INTO parts (ipn, category, description) VALUES (?, ?, ?)",
			fmt.Sprintf("PART-%04d", i), "Test", fmt.Sprintf("Part %d", i))
	}

	req := httptest.NewRequest("GET", "/api/export/parts?format=csv", nil)
	w := httptest.NewRecorder()

	handleExportParts(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	reader := csv.NewReader(w.Body)
	records, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("Failed to parse CSV: %v", err)
	}

	// Should have header + 1000 data rows
	if len(records) != 1001 {
		t.Errorf("Expected 1001 rows, got %d", len(records))
	}
}

func TestHandleExport_SQLInjection(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	insertExportTestData(t, db)

	sqlInjectionAttempts := []string{
		"'; DROP TABLE parts; --",
		"' OR '1'='1",
		"PART-001'; DELETE FROM parts WHERE '1'='1",
	}

	for _, attempt := range sqlInjectionAttempts {
		t.Run("SQL_Injection_"+attempt, func(t *testing.T) {
			req := httptest.NewRequest("GET", "/api/export/parts?format=csv&search="+attempt, nil)
			w := httptest.NewRecorder()

			handleExportParts(w, req)

			// Should not cause errors
			if w.Code != http.StatusOK {
				t.Errorf("Expected status 200, got %d", w.Code)
			}

			// Verify table still exists
			var count int
			err := db.QueryRow("SELECT COUNT(*) FROM parts").Scan(&count)
			if err != nil {
				t.Errorf("parts table damaged by SQL injection: %v", err)
			}
			if count != 5 {
				t.Errorf("Expected 5 parts, got %d - data may have been modified", count)
			}
		})
	}
}

func TestHandleExport_FormatValidation(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	insertExportTestData(t, db)

	tests := []struct {
		name               string
		format             string
		expectedContentType string
	}{
		{"Default to CSV", "", "text/csv"},
		{"Explicit CSV", "csv", "text/csv"},
		{"Excel format", "xlsx", "spreadsheetml"},
		{"Invalid format defaults to CSV", "invalid", "text/csv"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			url := "/api/export/parts"
			if tt.format != "" {
				url += "?format=" + tt.format
			}

			req := httptest.NewRequest("GET", url, nil)
			w := httptest.NewRecorder()

			handleExportParts(w, req)

			if w.Code != http.StatusOK {
				t.Errorf("Expected status 200, got %d", w.Code)
			}

			contentType := w.Header().Get("Content-Type")
			if !strings.Contains(contentType, tt.expectedContentType) {
				t.Errorf("Expected Content-Type to contain '%s', got '%s'", tt.expectedContentType, contentType)
			}
		})
	}
}

func TestHandleExport_EmptyResults(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	// Don't insert any data

	req := httptest.NewRequest("GET", "/api/export/parts?format=csv", nil)
	w := httptest.NewRecorder()

	handleExportParts(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	reader := csv.NewReader(w.Body)
	records, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("Failed to parse CSV: %v", err)
	}

	// Should still have header row
	if len(records) != 1 {
		t.Errorf("Expected 1 row (header only), got %d", len(records))
	}
}

func TestHandleExport_XSSInData(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	// Insert part with XSS payload
	xssPayload := "<script>alert('xss')</script>"
	db.Exec("INSERT INTO parts (ipn, description) VALUES (?, ?)", "XSS-001", xssPayload)

	req := httptest.NewRequest("GET", "/api/export/parts?format=csv", nil)
	w := httptest.NewRecorder()

	handleExportParts(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	body := w.Body.String()

	// CSV should properly escape/contain the data
	if !strings.Contains(body, xssPayload) && !strings.Contains(body, "script") {
		t.Error("XSS payload not found in export - may indicate data loss")
	}

	// The important thing is it's in CSV format which is safe
	reader := csv.NewReader(strings.NewReader(body))
	records, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("Failed to parse CSV with XSS data: %v", err)
	}

	if len(records) < 2 {
		t.Error("Expected at least header + 1 data row")
	}
}

func TestHandleExport_SpecialCharacters(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	// Insert parts with special characters
	specialChars := []string{
		"Test, with, commas",
		"Test \"with\" quotes",
		"Test\nwith\nnewlines",
		"Test	with	tabs",
	}

	for i, special := range specialChars {
		db.Exec("INSERT INTO parts (ipn, description) VALUES (?, ?)",
			fmt.Sprintf("SPECIAL-%d", i), special)
	}

	req := httptest.NewRequest("GET", "/api/export/parts?format=csv", nil)
	w := httptest.NewRecorder()

	handleExportParts(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	// Should be able to parse CSV despite special characters
	reader := csv.NewReader(w.Body)
	records, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("Failed to parse CSV with special characters: %v", err)
	}

	if len(records) < 5 {
		t.Errorf("Expected at least 5 rows, got %d", len(records))
	}
}

func TestHandleExport_ExcelMultipleSheets(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	insertExportTestData(t, db)

	req := httptest.NewRequest("GET", "/api/export/parts?format=xlsx", nil)
	w := httptest.NewRecorder()

	handleExportParts(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	f, err := excelize.OpenReader(w.Body)
	if err != nil {
		t.Fatalf("Failed to parse Excel file: %v", err)
	}
	defer f.Close()

	sheets := f.GetSheetList()

	// Should not have a leftover "Sheet1" if we created a custom sheet
	defaultSheetExists := false
	for _, sheet := range sheets {
		if sheet == "Sheet1" {
			defaultSheetExists = true
		}
	}

	// If we created "Parts" sheet, Sheet1 should be deleted
	if len(sheets) > 1 || (len(sheets) == 1 && sheets[0] == "Sheet1" && defaultSheetExists) {
		t.Log("Note: Default Sheet1 may still exist - check export implementation")
	}
}

func TestExportCSV_DirectFunction(t *testing.T) {
	headers := []string{"Col1", "Col2", "Col3"}
	data := [][]string{
		{"A", "B", "C"},
		{"D", "E", "F"},
	}

	w := httptest.NewRecorder()
	exportCSV(w, "test.csv", headers, data)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	reader := csv.NewReader(w.Body)
	records, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("Failed to parse CSV: %v", err)
	}

	if len(records) != 3 {
		t.Errorf("Expected 3 rows, got %d", len(records))
	}
}

func TestExportExcel_DirectFunction(t *testing.T) {
	headers := []string{"Col1", "Col2", "Col3"}
	data := [][]string{
		{"A", "B", "C"},
		{"D", "E", "F"},
	}

	w := httptest.NewRecorder()
	exportExcel(w, "TestSheet", headers, data)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	// Verify it's a valid Excel file
	_, err := excelize.OpenReader(w.Body)
	if err != nil {
		t.Fatalf("Failed to parse Excel file: %v", err)
	}
}

func TestLogDataExport(t *testing.T) {
	origDB := db
	defer func() { db = origDB }()
	db = setupExportTestDB(t)
	defer db.Close()

	req := httptest.NewRequest("GET", "/api/export/parts?format=csv", nil)
	req.Header.Set("X-User-ID", "test-user")

	LogDataExport(db, req, "parts", "csv", 100)

	// Verify log was created
	var count int
	err := db.QueryRow("SELECT COUNT(*) FROM data_exports WHERE entity_type = ? AND format = ?", "parts", "csv").Scan(&count)
	if err != nil {
		t.Fatalf("Failed to query export log: %v", err)
	}

	if count != 1 {
		t.Errorf("Expected 1 export log entry, got %d", count)
	}
}
