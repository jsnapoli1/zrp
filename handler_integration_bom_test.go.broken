package main

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	_ "modernc.org/sqlite"
)

// TestBOMShortageWorkflow tests the complete workflow from checking BOM shortages
// to generating a PO to resolve them
func TestBOMShortageWorkflow(t *testing.T) {
	// Setup test database
	testDB := setupBOMIntegrationTestDB(t)
	defer testDB.Close()
	db = testDB // Set global db for handlers

	// Seed test data
	seedBOMTestData(t, testDB)

	// Create router
	mux := http.NewServeMux()
	mux.HandleFunc("/api/v1/workorders/{id}/bom-check", handleCheckWOBOM)
	mux.HandleFunc("/api/v1/workorders/{id}/generate-po", handleGeneratePOFromWO)
	mux.HandleFunc("/api/v1/pos/{id}", handleGetPO)

	t.Run("CheckBOMShortages", func(t *testing.T) {
		// Check BOM for work order that has shortages
		req := httptest.NewRequest("GET", "/api/v1/workorders/WO-001/bom-check", nil)
		w := httptest.NewRecorder()

		mux.ServeHTTP(w, req)

		if w.Code != http.StatusOK {
			t.Fatalf("Expected status 200, got %d", w.Code)
		}

		var response APIResponse
		if err := json.NewDecoder(w.Body).Decode(&response); err != nil {
			t.Fatalf("Failed to decode response: %v", err)
		}

		data := response.Data.(map[string]interface{})
		shortages := data["shortages"].([]interface{})

		if len(shortages) == 0 {
			t.Error("Expected shortages for components, got none")
			t.Logf("Note: This might indicate gap 4.1 - no BOM check implementation")
		} else {
			t.Logf("✓ Found %d shortages as expected", len(shortages))
			for i, s := range shortages {
				shortage := s.(map[string]interface{})
				t.Logf("  Shortage %d: %v", i+1, shortage)
			}
		}
	})

	t.Run("GeneratePOFromShortages", func(t *testing.T) {
		// Generate PO from work order shortages
		payload := map[string]interface{}{
			"vendor_id": "V-001",
		}

		body, _ := json.Marshal(payload)
		req := httptest.NewRequest("POST", "/api/v1/workorders/WO-001/generate-po", bytes.NewBuffer(body))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		mux.ServeHTTP(w, req)

		if w.Code != http.StatusOK {
			t.Fatalf("Expected status 200, got %d: %s", w.Code, w.Body.String())
		}

		var response APIResponse
		if err := json.NewDecoder(w.Body).Decode(&response); err != nil {
			t.Fatalf("Failed to decode response: %v", err)
		}

		data := response.Data.(map[string]interface{})
		poID, ok := data["po_id"].(string)
		
		if !ok || poID == "" {
			t.Fatal("Generated PO ID is empty")
		}

		t.Logf("✓ Generated PO: %s", poID)

		// Verify PO was created in database
		var count int
		err := db.QueryRow("SELECT COUNT(*) FROM purchase_orders WHERE id = ?", poID).Scan(&count)
		if err != nil {
			t.Fatalf("Failed to query PO: %v", err)
		}

		if count == 0 {
			t.Error("PO was not created in database")
		} else {
			t.Logf("✓ PO exists in database")
		}

		// Verify PO has line items
		err = db.QueryRow("SELECT COUNT(*) FROM po_lines WHERE po_id = ?", poID).Scan(&count)
		if err != nil {
			t.Fatalf("Failed to query PO lines: %v", err)
		}

		if count == 0 {
			t.Error("PO has no line items")
		} else {
			t.Logf("✓ PO has %d line items", count)
		}
	})
}

// TestWorkOrderCompletionInventoryUpdate tests that completing a WO updates inventory
// This addresses WORKFLOW_GAPS.md gap 4.5
func TestWorkOrderCompletionInventoryUpdate(t *testing.T) {
	testDB := setupBOMIntegrationTestDB(t)
	defer testDB.Close()
	db = testDB

	// Create assembly inventory record
	_, err := db.Exec(`INSERT INTO inventory (ipn, qty_on_hand, qty_reserved) VALUES ('ASY-001', 0.0, 0.0)`)
	if err != nil {
		t.Fatalf("Failed to create inventory: %v", err)
	}

	// Create work order
	_, err = db.Exec(`INSERT INTO work_orders (id, assembly_ipn, qty, status) VALUES ('WO-TEST', 'ASY-001', 10, 'open')`)
	if err != nil {
		t.Fatalf("Failed to create work order: %v", err)
	}

	// Get initial inventory
	var initialQty float64
	err = db.QueryRow("SELECT qty_on_hand FROM inventory WHERE ipn = 'ASY-001'").Scan(&initialQty)
	if err != nil {
		t.Fatalf("Failed to query initial inventory: %v", err)
	}

	t.Logf("Initial inventory for ASY-001: %v", initialQty)

	// Complete the work order
	_, err = db.Exec(`UPDATE work_orders SET status = 'completed' WHERE id = 'WO-TEST'`)
	if err != nil {
		t.Fatalf("Failed to update work order: %v", err)
	}

	// Check if inventory was automatically updated
	var finalQty float64
	err = db.QueryRow("SELECT qty_on_hand FROM inventory WHERE ipn = 'ASY-001'").Scan(&finalQty)
	if err != nil {
		t.Fatalf("Failed to query final inventory: %v", err)
	}

	expectedQty := initialQty + 10.0
	if finalQty != expectedQty {
		t.Logf("⚠️  KNOWN GAP 4.5: Completing WO does NOT auto-update inventory")
		t.Logf("   Initial: %v, Final: %v, Expected: %v", initialQty, finalQty, expectedQty)
		t.Logf("   Work order completion should add finished goods to inventory")
	} else {
		t.Logf("✓ Inventory correctly updated from %v to %v", initialQty, finalQty)
	}

	// Check if materials were consumed (for reference)
	// This would require checking component inventory levels
	t.Logf("Note: Component consumption check would require full BOM implementation")
}

// TestInventoryReservationOnWOCreate tests that creating a WO reserves materials
// This addresses WORKFLOW_GAPS.md gap 4.1
func TestInventoryReservationOnWOCreate(t *testing.T) {
	testDB := setupBOMIntegrationTestDB(t)
	defer testDB.Close()
	db = testDB

	// Create component inventory with available stock
	_, err := db.Exec(`INSERT INTO inventory (ipn, qty_on_hand, qty_reserved) VALUES ('RES-001', 100.0, 0.0)`)
	if err != nil {
		t.Fatalf("Failed to create inventory: %v", err)
	}

	// Create BOM entry showing ASY-001 needs 10x RES-001
	_, err = db.Exec(`INSERT INTO boms (parent_ipn, child_ipn, quantity) VALUES ('ASY-001', 'RES-001', 10)`)
	if err != nil {
		t.Fatalf("Failed to create BOM: %v", err)
	}

	// Get initial reserved quantity
	var initialReserved float64
	err = db.QueryRow("SELECT qty_reserved FROM inventory WHERE ipn = 'RES-001'").Scan(&initialReserved)
	if err != nil {
		t.Fatalf("Failed to query initial reserved: %v", err)
	}

	t.Logf("Initial reserved quantity for RES-001: %v", initialReserved)

	// Create work order for 5x ASY-001 (requires 50x RES-001)
	_, err = db.Exec(`INSERT INTO work_orders (id, assembly_ipn, qty, status) VALUES ('WO-RES-TEST', 'ASY-001', 5, 'open')`)
	if err != nil {
		t.Fatalf("Failed to create work order: %v", err)
	}

	// Check if inventory was reserved
	var finalReserved float64
	err = db.QueryRow("SELECT qty_reserved FROM inventory WHERE ipn = 'RES-001'").Scan(&finalReserved)
	if err != nil {
		t.Fatalf("Failed to query final reserved: %v", err)
	}

	expectedReserved := initialReserved + 50.0
	if finalReserved != expectedReserved {
		t.Logf("⚠️  KNOWN GAP 4.1: Creating WO does NOT reserve materials")
		t.Logf("   Initial reserved: %v, Final reserved: %v, Expected: %v", initialReserved, finalReserved, expectedReserved)
		t.Logf("   Work orders should reserve materials when created")
	} else {
		t.Logf("✓ Materials correctly reserved: %v units", finalReserved)
	}
}

func setupBOMIntegrationTestDB(t *testing.T) *sql.DB {
	db, err := sql.Open("sqlite3", ":memory:")
	if err != nil {
		t.Fatal(err)
	}

	tables := []string{
		`CREATE TABLE work_orders (
			id TEXT PRIMARY KEY,
			assembly_ipn TEXT NOT NULL,
			qty INTEGER NOT NULL DEFAULT 1,
			status TEXT NOT NULL DEFAULT 'open',
			priority TEXT DEFAULT 'normal',
			notes TEXT,
			created_at TEXT,
			completed_at TEXT
		)`,
		`CREATE TABLE inventory (
			ipn TEXT PRIMARY KEY,
			qty_on_hand REAL NOT NULL DEFAULT 0,
			qty_reserved REAL NOT NULL DEFAULT 0,
			reorder_point REAL DEFAULT 0,
			reorder_qty REAL DEFAULT 0
		)`,
		`CREATE TABLE boms (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			parent_ipn TEXT NOT NULL,
			child_ipn TEXT NOT NULL,
			quantity REAL NOT NULL,
			UNIQUE(parent_ipn, child_ipn)
		)`,
		`CREATE TABLE purchase_orders (
			id TEXT PRIMARY KEY,
			vendor_id TEXT,
			status TEXT DEFAULT 'draft',
			total REAL DEFAULT 0,
			created_at TEXT,
			ordered_date TEXT
		)`,
		`CREATE TABLE po_lines (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			po_id TEXT NOT NULL,
			ipn TEXT,
			mpn TEXT,
			manufacturer TEXT,
			quantity REAL,
			unit_price REAL,
			FOREIGN KEY (po_id) REFERENCES purchase_orders(id)
		)`,
		`CREATE TABLE vendors (
			id TEXT PRIMARY KEY,
			name TEXT NOT NULL,
			status TEXT DEFAULT 'active',
			lead_time_days INTEGER DEFAULT 0
		)`,
		`CREATE TABLE audit_log (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			user_id INTEGER,
			username TEXT DEFAULT 'system',
			action TEXT NOT NULL,
			module TEXT NOT NULL,
			record_id TEXT NOT NULL,
			summary TEXT,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP
		)`,
	}

	for _, table := range tables {
		if _, err := db.Exec(table); err != nil {
			t.Fatalf("Failed to create table: %v", err)
		}
	}

	return db
}

func seedBOMTestData(t *testing.T, db *sql.DB) {
	// Create vendor
	_, err := db.Exec(`INSERT INTO vendors (id, name, status) VALUES ('V-001', 'Test Vendor', 'active')`)
	if err != nil {
		t.Fatalf("Failed to seed vendor: %v", err)
	}

	// Create inventory records with low stock
	inventory := []struct {
		ipn          string
		qtyOnHand    float64
		reorderPoint float64
	}{
		{"RES-001", 5.0, 50.0},   // Component with shortage
		{"CAP-001", 2.0, 25.0},   // Component with shortage
		{"ASY-001", 0.0, 10.0},   // Assembly - will be built
	}

	for _, inv := range inventory {
		_, err := db.Exec(`INSERT INTO inventory (ipn, qty_on_hand, qty_reserved, reorder_point, reorder_qty) 
			VALUES (?, ?, 0, ?, ?)`, inv.ipn, inv.qtyOnHand, inv.reorderPoint, inv.reorderPoint*2)
		if err != nil {
			t.Fatalf("Failed to seed inventory %s: %v", inv.ipn, err)
		}
	}

	// Create BOM for ASY-001
	boms := []struct {
		parent string
		child  string
		qty    float64
	}{
		{"ASY-001", "RES-001", 10.0},
		{"ASY-001", "CAP-001", 5.0},
	}

	for _, bom := range boms {
		_, err := db.Exec(`INSERT INTO boms (parent_ipn, child_ipn, quantity) VALUES (?, ?, ?)`,
			bom.parent, bom.child, bom.qty)
		if err != nil {
			t.Fatalf("Failed to seed BOM: %v", err)
		}
	}

	// Create work order that will have shortages
	_, err = db.Exec(`INSERT INTO work_orders (id, assembly_ipn, qty, status) VALUES ('WO-001', 'ASY-001', 10, 'open')`)
	if err != nil {
		t.Fatalf("Failed to seed work order: %v", err)
	}
}
